const filterOptions = (options, search) => {
    const result = [];
    options.forEach((item) => {
        if (typeof item !== 'string' && 'options' in item && Array.isArray(item.options)) {
            const filteredOptions = filterOptions(item.options, search);
            if (filteredOptions.length > 0) {
                result.push(Object.assign(Object.assign({}, item), { options: filteredOptions }));
            }
        }
        else if (getOptionLabel(item).toLowerCase().includes(search.toLowerCase())) {
            result.push(item);
        }
    });
    return result;
};
const flattenOptionsArray = (options) => {
    const optionsList = [];
    for (const option of options) {
        if (typeof option !== 'string' && 'options' in option && Array.isArray(option.options)) {
            optionsList.push(...option.options);
        }
        else {
            optionsList.push(option);
        }
    }
    return optionsList;
};
const isExternalSearch = (search) => {
    return ((typeof search === 'string' && search === 'external') ||
        (typeof search === 'object' && search.external === true));
};
const isGlobalSearch = (search) => {
    return ((typeof search === 'string' && search === 'global') ||
        (typeof search === 'object' && search.global === true));
};
const getOptionLabel = (option) => typeof option === 'string' ? option : option.label;
const highlightSubstring = (string, query) => {
    if (query) {
        const regex = new RegExp(query, 'gi');
        return string.replace(regex, (string) => `<strong>${string}</strong>`);
    }
    return string;
};
const isOptionDisabled = (option) => typeof option === 'string' ? false : option.disabled;
const isOptionSelected = (option, selected) => {
    if (!selected) {
        return false;
    }
    if (typeof option === 'string' && typeof selected === 'string') {
        return selected === option;
    }
    if (typeof option !== 'string' && typeof selected !== 'string') {
        return selected.label === option.label;
    }
    return false;
};
const getFirstOptionByLabel = (value, options) => {
    for (const option of options) {
        if (typeof option !== 'string' && 'options' in option && Array.isArray(option.options)) {
            const found = getFirstOptionByLabel(value, option.options);
            if (found) {
                return found;
            }
        }
        if (getOptionLabel(option).toLowerCase() === value.toLowerCase()) {
            return option;
        }
    }
    return null;
};
const getFirstOptionByValue = (value, options) => {
    for (const option of options) {
        if (typeof option !== 'string' && 'options' in option && Array.isArray(option.options)) {
            const found = getFirstOptionByValue(value, option.options);
            if (found) {
                return found;
            }
        }
        if (typeof option !== 'string' && 'value' in option && option.value === value) {
            return option;
        }
    }
    return null;
};

export { filterOptions, flattenOptionsArray, getFirstOptionByLabel, getFirstOptionByValue, getOptionLabel, highlightSubstring, isExternalSearch, isGlobalSearch, isOptionDisabled, isOptionSelected };
//# sourceMappingURL=utils.js.map
