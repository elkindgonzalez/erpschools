'use strict';

var tslib_es6 = require('../../node_modules/tslib/tslib.es6.js');
var React = require('react');
var PropTypes = require('prop-types');
var index = require('../../_virtual/index.js');
require('@popperjs/core');
var isRTL = require('../../utils/isRTL.js');
var useForkedRef = require('../../hooks/useForkedRef.js');
var utils = require('./utils.js');

const CRangeSlider = React.forwardRef((_a, ref) => {
    var { className, clickableLabels = true, disabled = false, distance = 0, labels, min = 0, max = 100, name, step = 1, value = [], onChange, tooltips = true, tooltipsFormat, track = 'fill', vertical = false } = _a, rest = tslib_es6.__rest(_a, ["className", "clickableLabels", "disabled", "distance", "labels", "min", "max", "name", "step", "value", "onChange", "tooltips", "tooltipsFormat", "track", "vertical"]);
    const rangeSliderRef = React.useRef(null);
    const forkedRef = useForkedRef.useForkedRef(ref, rangeSliderRef);
    const inputsRef = React.useRef([]);
    const labelsContainerRef = React.useRef(null);
    const labelsRef = React.useRef([]);
    const trackRef = React.useRef(null);
    const [currentValue, setCurrentValue] = React.useState(Array.isArray(value) ? value : [value]);
    const [isDragging, setIsDragging] = React.useState(false);
    const [_isRTL, setIsRTL] = React.useState(false);
    const [dragIndex, setDragIndex] = React.useState(0);
    const [thumbSize, setThumbSize] = React.useState();
    React.useEffect(() => {
        setCurrentValue(Array.isArray(value) ? value : [value]);
    }, [value]);
    React.useEffect(() => {
        if (rangeSliderRef.current) {
            setIsRTL(isRTL.default(rangeSliderRef.current));
            setThumbSize(utils.getThumbSize(rangeSliderRef.current, vertical));
        }
    }, [rangeSliderRef]);
    React.useEffect(() => {
        const maxSize = Math.max(...labelsRef.current.map((label) => (vertical ? label.offsetWidth : label.offsetHeight)));
        if (labelsContainerRef.current) {
            labelsContainerRef.current.style[vertical ? 'width' : 'height'] = `${maxSize}px`;
        }
    }, [labelsRef]);
    React.useEffect(() => {
        if (isDragging) {
            document.addEventListener('mousemove', handleMouseMove);
            document.addEventListener('mouseup', handleMouseUp);
        }
        return () => {
            document.removeEventListener('mousemove', handleMouseMove);
            document.removeEventListener('mouseup', handleMouseUp);
        };
    }, [currentValue]);
    const updateNearestValue = (value) => {
        const nearestIndex = utils.getNearestValueIndex(value, currentValue);
        const newCurrentValue = [...currentValue];
        newCurrentValue[nearestIndex] = utils.validateValue(value, currentValue, distance, nearestIndex);
        setTimeout(() => {
            inputsRef.current[nearestIndex].focus();
        });
        setCurrentValue(newCurrentValue);
        if (onChange) {
            onChange(newCurrentValue);
        }
    };
    const handleInputChange = (event, index) => {
        setIsDragging(false);
        const target = event.target;
        const value = Number(target.value);
        const newCurrentValue = utils.updateValue(value, currentValue, distance, index);
        setCurrentValue(newCurrentValue);
        // Trigger change event if needed
        if (onChange) {
            onChange(newCurrentValue);
        }
    };
    const handleInputsContainerMouseDown = (event) => {
        if (trackRef.current === null || event.button !== 0 || disabled) {
            return;
        }
        const target = event.target;
        if (!(target instanceof HTMLInputElement) && target !== trackRef.current) {
            return;
        }
        const clickValue = utils.calculateClickValue(event, trackRef.current, min, max, step, vertical, _isRTL);
        const index = utils.getNearestValueIndex(clickValue, currentValue);
        setIsDragging(true);
        setDragIndex(index);
        updateNearestValue(clickValue);
    };
    const handleLabelClick = (event, value) => {
        if (!clickableLabels || disabled || event.button !== 0) {
            return;
        }
        updateNearestValue(value);
    };
    const handleMouseMove = (event) => {
        if (!isDragging || trackRef.current === null || disabled) {
            return;
        }
        const moveValue = utils.calculateMoveValue(event, trackRef.current, min, max, step, vertical, _isRTL);
        const newCurrentValue = utils.updateValue(moveValue, currentValue, distance, dragIndex);
        setCurrentValue(newCurrentValue);
        if (onChange) {
            onChange(newCurrentValue);
        }
    };
    const handleMouseUp = () => {
        setIsDragging(false);
    };
    return (React.createElement("div", Object.assign({ className: index.default('range-slider', className, {
            'range-slider-vertical': vertical,
            disabled,
        }) }, rest, { ref: forkedRef }),
        React.createElement("div", { className: "range-slider-inputs-container", onMouseDown: handleInputsContainerMouseDown },
            currentValue.map((value, index) => (React.createElement(React.Fragment, { key: index },
                React.createElement("input", { className: "range-slider-input", type: "range", min: min, max: max, step: step, value: value, name: Array.isArray(name) ? name[index] : `${name || ''}-${index}}`, role: "slider", "aria-valuemin": min, "aria-valuemax": max, "aria-valuenow": value, "aria-orientation": vertical ? 'vertical' : 'horizontal', disabled: disabled, onChange: (event) => handleInputChange(event, index), ref: (el) => {
                        inputsRef.current[index] = el;
                    } }),
                tooltips && (React.createElement("div", Object.assign({ className: "range-slider-tooltip" }, (thumbSize && {
                    style: utils.calculateTooltipPosition(min, max, value, thumbSize, vertical, _isRTL),
                })),
                    React.createElement("div", { className: "range-slider-tooltip-inner" }, tooltipsFormat ? tooltipsFormat(value) : value),
                    React.createElement("div", { className: "range-slider-tooltip-arrow" })))))),
            React.createElement("div", Object.assign({ className: "range-slider-track" }, (track && {
                style: utils.updateGradient(min, max, currentValue, vertical, _isRTL),
            }), { ref: trackRef }))),
        labels && (React.createElement("div", { className: "range-slider-labels-container", ref: labelsContainerRef }, Array.isArray(labels) &&
            labels.map((label, index$1) => {
                const labelPosition = utils.calculateLabelPosition(min, max, labels, label, index$1);
                const labelValue = utils.getLabelValue(min, max, labels, label, index$1);
                const labelStyle = Object.assign(vertical
                    ? { bottom: labelPosition }
                    : _isRTL
                        ? { right: labelPosition }
                        : { left: labelPosition }, typeof label === 'object' && 'style' in label && label.style);
                return (React.createElement("div", { className: index.default('range-slider-label', {
                        clickable: clickableLabels,
                    }, typeof label === 'object' && 'className' in label && label.className), style: labelStyle, onMouseDown: (event) => handleLabelClick(event, labelValue), key: index$1, ref: (el) => {
                        labelsRef.current[index$1] = el;
                    } }, typeof label === 'object' && 'label' in label ? label.label : label));
            })))));
});
CRangeSlider.propTypes = {
    clickableLabels: PropTypes.bool,
    disabled: PropTypes.bool,
    distance: PropTypes.number,
    labels: PropTypes.any,
    max: PropTypes.number,
    min: PropTypes.number,
    name: PropTypes.oneOfType([PropTypes.array, PropTypes.string]),
    step: PropTypes.number,
    tooltips: PropTypes.bool,
    tooltipsFormat: PropTypes.func,
    track: PropTypes.oneOfType([PropTypes.bool, PropTypes.oneOf(['fill'])]),
    value: PropTypes.oneOfType([PropTypes.array, PropTypes.number]),
    vertical: PropTypes.bool,
};
CRangeSlider.displayName = 'CRangeSlider';

exports.CRangeSlider = CRangeSlider;
//# sourceMappingURL=CRangeSlider.js.map
